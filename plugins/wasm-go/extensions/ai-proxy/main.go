// File generated by hgctl. Modify as required.
// See: https://higress.io/zh-cn/docs/user/wasm-go#2-%E7%BC%96%E5%86%99-maingo-%E6%96%87%E4%BB%B6

package main

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/alibaba/higress/plugins/wasm-go/extensions/ai-proxy/config"
	"github.com/alibaba/higress/plugins/wasm-go/extensions/ai-proxy/provider"
	"github.com/alibaba/higress/plugins/wasm-go/extensions/ai-proxy/util"
	"github.com/alibaba/higress/plugins/wasm-go/pkg/log"
	"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

const (
	pluginName = "ai-proxy"

	defaultMaxBodyBytes uint32 = 100 * 1024 * 1024
)

func main() {
	wrapper.SetCtx(
		pluginName,
		wrapper.ParseOverrideConfig(parseGlobalConfig, parseOverrideRuleConfig),
		wrapper.ProcessRequestHeaders(onHttpRequestHeader),
		wrapper.ProcessRequestBody(onHttpRequestBody),
		wrapper.ProcessResponseHeaders(onHttpResponseHeaders),
		wrapper.ProcessStreamingResponseBody(onStreamingResponseBody),
		wrapper.ProcessResponseBody(onHttpResponseBody),
	)
}

func parseGlobalConfig(json gjson.Result, pluginConfig *config.PluginConfig) error {
	log.Debugf("loading global config: %s", json.String())

	pluginConfig.FromJson(json)
	if err := pluginConfig.Validate(); err != nil {
		log.Errorf("global rule config is invalid: %v", err)
		return err
	}
	if err := pluginConfig.Complete(); err != nil {
		log.Errorf("failed to apply global rule config: %v", err)
		return err
	}

	return nil
}

func parseOverrideRuleConfig(json gjson.Result, global config.PluginConfig, pluginConfig *config.PluginConfig) error {
	log.Debugf("loading override rule config: %s", json.String())

	*pluginConfig = global

	pluginConfig.FromJson(json)
	if err := pluginConfig.Validate(); err != nil {
		log.Errorf("overriden rule config is invalid: %v", err)
		return err
	}
	if err := pluginConfig.Complete(); err != nil {
		log.Errorf("failed to apply overriden rule config: %v", err)
		return err
	}

	return nil
}

func onHttpRequestHeader(ctx wrapper.HttpContext, pluginConfig config.PluginConfig) types.Action {
	// Handle /ai-gateway/api/v1/models request locally first (before model selection)
	rawPath := ctx.Path()
	path, _ := url.Parse(rawPath)
	apiName := getApiName(path.Path)

	if apiName == provider.ApiNameModels {
		log.Debugf("[onHttpRequestHeader] handling /ai-gateway/api/v1/models request locally")
		ctx.DontReadRequestBody()

		// Generate models response based on all configured providers
		responseBody, err := pluginConfig.BuildCombinedModelsResponse()
		if err != nil {
			log.Errorf("failed to build models response: %v", err)
			_ = util.ErrorHandler("ai-proxy.build_models_failed", fmt.Errorf("failed to build models response: %v", err))
			return types.ActionContinue
		}

		// Send HTTP response directly
		headers := [][2]string{
			{"content-type", "application/json"},
		}
		err = proxywasm.SendHttpResponse(200, headers, responseBody, -1)
		if err != nil {
			log.Errorf("failed to send response: %v", err)
			_ = util.ErrorHandler("ai-proxy.send_models_response_failed", fmt.Errorf("failed to send response: %v", err))
			return types.ActionContinue
		}

		log.Debugf("[onHttpRequestHeader] models response sent: %s", string(responseBody))
		return types.ActionContinue
	}

	// Get model name from request for provider selection
	if contentType, _ := proxywasm.GetHttpRequestHeader(util.HeaderContentType); contentType != "" && strings.Contains(contentType, util.MimeTypeApplicationJson) {
		// For requests with body, we'll extract model in onHttpRequestBody
		// For now, use a placeholder to avoid null provider
		if len(pluginConfig.GetProviderConfigs()) > 0 {
			ctx.SetContext("needs_model_extraction", true)
		}
	}

	// Try to get active provider first (for legacy single provider configuration)
	activeProviderConfig := pluginConfig.GetProviderConfig()
	var activeProvider provider.Provider

	if activeProviderConfig != nil {
		// Legacy single provider configuration
		activeProvider = pluginConfig.GetProvider()
	} else {
		// Multi-provider configuration - we'll determine the provider later based on model
		// Use first provider as temporary fallback
		providerConfigs := pluginConfig.GetProviderConfigs()
		if len(providerConfigs) == 0 {
			log.Debugf("[onHttpRequestHeader] no providers configured, skip processing")
			ctx.DontReadRequestBody()
			return types.ActionContinue
		}

		// Store provider configs in context for later use
		ctx.SetContext("providerConfigs", providerConfigs)
	}

	// If we have a selected provider, continue with it
	if activeProvider != nil {
		log.Debugf("[onHttpRequestHeader] using provider=%s", activeProvider.GetProviderType())

		// Store provider info in context
		ctx.SetContext("activeProvider", activeProvider)
		ctx.SetContext("activeProviderConfig", activeProviderConfig)
	} else {
		log.Debugf("[onHttpRequestHeader] multi-provider mode, will select provider based on model")
	}

	// Handle protocol checking for existing provider
	if activeProviderConfig != nil && activeProviderConfig.IsOriginal() {
		if handler, ok := activeProvider.(provider.ApiNameHandler); ok {
			apiName = handler.GetApiName(path.Path)
		}
	}

	if contentType, _ := proxywasm.GetHttpRequestHeader(util.HeaderContentType); contentType != "" && !strings.Contains(contentType, util.MimeTypeApplicationJson) {
		ctx.DontReadRequestBody()
		log.Debugf("[onHttpRequestHeader] unsupported content type: %s, will not process the request body", contentType)
	}

	if apiName == "" {
		ctx.DontReadRequestBody()
		ctx.DontReadResponseBody()
		log.Warnf("[onHttpRequestHeader] unsupported path: %s, will not process http path and body", path.Path)
	}

	ctx.SetContext(provider.CtxKeyApiName, apiName)
	// Disable the route re-calculation since the plugin may modify some headers related to the chosen route.
	ctx.DisableReroute()

	// Always remove the Accept-Encoding header to prevent the LLM from sending compressed responses,
	// allowing plugins to inspect or modify the response correctly
	_ = proxywasm.RemoveHttpRequestHeader("Accept-Encoding")

	// If we have an active provider, process headers immediately
	if activeProvider != nil && activeProviderConfig != nil {
		if handler, ok := activeProvider.(provider.RequestHeadersHandler); ok {
			// Set the apiToken for the current request.
			activeProviderConfig.SetApiTokenInUse(ctx)
			// Set available apiTokens of current request in the context, will be used in the retryOnFailure
			activeProviderConfig.SetAvailableApiTokens(ctx)

			// save the original request host and path in case they are needed for apiToken health check and retry
			ctx.SetContext(provider.CtxRequestHost, wrapper.GetRequestHost())
			ctx.SetContext(provider.CtxRequestPath, wrapper.GetRequestPath())

			err := handler.OnRequestHeaders(ctx, apiName)
			if err != nil {
				_ = util.ErrorHandler("ai-proxy.proc_req_headers_failed", fmt.Errorf("failed to process request headers: %v", err))
				return types.ActionContinue
			}

			hasRequestBody := wrapper.HasRequestBody()
			if hasRequestBody {
				_ = proxywasm.RemoveHttpRequestHeader("Content-Length")
				ctx.SetRequestBodyBufferLimit(defaultMaxBodyBytes)
				// Delay the header processing to allow changing in OnRequestBody
				return types.HeaderStopIteration
			}
			ctx.DontReadRequestBody()
			return types.ActionContinue
		}
	} else {
		// Multi-provider mode: need to read body to extract model
		hasRequestBody := wrapper.HasRequestBody()
		if hasRequestBody {
			_ = proxywasm.RemoveHttpRequestHeader("Content-Length")
			ctx.SetRequestBodyBufferLimit(defaultMaxBodyBytes)
			return types.HeaderStopIteration
		}
		ctx.DontReadRequestBody()
	}

	return types.ActionContinue
}

func onHttpRequestBody(ctx wrapper.HttpContext, pluginConfig config.PluginConfig, body []byte) types.Action {
	// Try to get provider from context (set in header phase)
	var activeProvider provider.Provider
	var activeProviderConfig *provider.ProviderConfig

	if providerInstance, ok := ctx.GetContext("activeProvider").(provider.Provider); ok {
		// Legacy single provider mode
		activeProvider = providerInstance
		if config, ok := ctx.GetContext("activeProviderConfig").(*provider.ProviderConfig); ok {
			activeProviderConfig = config
		}
	} else {
		// Multi-provider mode: select provider based on model in request
		if needsExtraction, _ := ctx.GetContext("needs_model_extraction").(bool); needsExtraction {
			// Extract model name from request body
			modelName := gjson.GetBytes(body, "model").String()
			if modelName != "" {
				log.Debugf("[onHttpRequestBody] extracted model name: %s", modelName)

				// Select provider based on model
				selectedConfig, selectedProvider := pluginConfig.GetProviderForModel(modelName)
				if selectedConfig != nil && selectedProvider != nil {
					activeProviderConfig = selectedConfig
					activeProvider = selectedProvider

					log.Debugf("[onHttpRequestBody] selected provider=%s for model=%s", selectedProvider.GetProviderType(), modelName)

					// Set up the selected provider (similar to header phase)
					activeProviderConfig.SetApiTokenInUse(ctx)
					activeProviderConfig.SetAvailableApiTokens(ctx)
					ctx.SetContext("requestHost", wrapper.GetRequestHost())
					ctx.SetContext("requestPath", wrapper.GetRequestPath())

					// Process request headers for the selected provider
					if handler, ok := selectedProvider.(provider.RequestHeadersHandler); ok {
						apiName, _ := ctx.GetContext(provider.CtxKeyApiName).(provider.ApiName)
						err := handler.OnRequestHeaders(ctx, apiName)
						if err != nil {
							log.Errorf("failed to process request headers for provider %s: %v", selectedProvider.GetProviderType(), err)
							_ = util.ErrorHandler("ai-proxy.proc_req_headers_failed", fmt.Errorf("failed to process request headers: %v", err))
							return types.ActionContinue
						}
					}
				} else {
					log.Warnf("[onHttpRequestBody] no provider can handle model: %s", modelName)
					return types.ActionContinue
				}
			} else {
				log.Warnf("[onHttpRequestBody] no model found in request body")
				return types.ActionContinue
			}
		}
	}

	if activeProvider == nil {
		log.Debugf("[onHttpRequestBody] no active provider, skip processing")
		return types.ActionContinue
	}

	log.Debugf("[onHttpRequestBody] provider=%s", activeProvider.GetProviderType())

	if handler, ok := activeProvider.(provider.RequestBodyHandler); ok {
		apiName, _ := ctx.GetContext(provider.CtxKeyApiName).(provider.ApiName)
		// If retryOnFailure is enabled, save the transformed body to the context in case of retry
		if activeProviderConfig.IsRetryOnFailureEnabled() {
			ctx.SetContext("requestBody", body)
		}
		newBody, settingErr := activeProviderConfig.ReplaceByCustomSettings(body)
		if settingErr != nil {
			log.Errorf("failed to replace request body by custom settings: %v", settingErr)
		}
		if activeProviderConfig.IsOpenAIProtocol() {
			newBody = normalizeOpenAiRequestBody(newBody)
		}
		log.Debugf("[onHttpRequestBody] newBody=%s", newBody)
		body = newBody
		action, err := handler.OnRequestBody(ctx, apiName, body)
		if err == nil {
			return action
		}
		_ = util.ErrorHandler("ai-proxy.proc_req_body_failed", fmt.Errorf("failed to process request body: %v", err))
	}
	return types.ActionContinue
}

func onHttpResponseHeaders(ctx wrapper.HttpContext, pluginConfig config.PluginConfig) types.Action {
	if !wrapper.IsResponseFromUpstream() {
		// Response is not coming from the upstream. Let it pass through.
		ctx.DontReadResponseBody()
		return types.ActionContinue
	}

	activeProvider := pluginConfig.GetProvider()

	if activeProvider == nil {
		log.Debugf("[onHttpResponseHeaders] no active provider, skip processing")
		ctx.DontReadResponseBody()
		return types.ActionContinue
	}

	log.Debugf("[onHttpResponseHeaders] provider=%s", activeProvider.GetProviderType())

	providerConfig := pluginConfig.GetProviderConfig()
	apiTokenInUse := providerConfig.GetApiTokenInUse(ctx)
	apiTokens := providerConfig.GetAvailableApiToken(ctx)

	status, err := proxywasm.GetHttpResponseHeader(":status")
	if err != nil || status != "200" {
		if err != nil {
			log.Errorf("unable to load :status header from response: %v", err)
		}
		ctx.DontReadResponseBody()
		return providerConfig.OnRequestFailed(activeProvider, ctx, apiTokenInUse, apiTokens, status)
	}

	// Reset ctxApiTokenRequestFailureCount if the request is successful,
	// the apiToken is removed only when the number of consecutive request failures exceeds the threshold.
	providerConfig.ResetApiTokenRequestFailureCount(apiTokenInUse)

	headers := util.GetOriginalResponseHeaders()
	if handler, ok := activeProvider.(provider.TransformResponseHeadersHandler); ok {
		apiName, _ := ctx.GetContext(provider.CtxKeyApiName).(provider.ApiName)
		handler.TransformResponseHeaders(ctx, apiName, headers)
	} else {
		providerConfig.DefaultTransformResponseHeaders(ctx, headers)
	}
	util.ReplaceResponseHeaders(headers)

	checkStream(ctx)
	_, needHandleBody := activeProvider.(provider.TransformResponseBodyHandler)
	var needHandleStreamingBody bool
	_, needHandleStreamingBody = activeProvider.(provider.StreamingResponseBodyHandler)
	if !needHandleStreamingBody {
		_, needHandleStreamingBody = activeProvider.(provider.StreamingEventHandler)
	}
	if !needHandleBody && !needHandleStreamingBody {
		ctx.DontReadResponseBody()
	} else if !needHandleStreamingBody {
		ctx.BufferResponseBody()
	}

	return types.ActionContinue
}

func onStreamingResponseBody(ctx wrapper.HttpContext, pluginConfig config.PluginConfig, chunk []byte, isLastChunk bool) []byte {
	activeProvider := pluginConfig.GetProvider()

	if activeProvider == nil {
		log.Debugf("[onStreamingResponseBody] no active provider, skip processing")
		return chunk
	}

	log.Debugf("[onStreamingResponseBody] provider=%s", activeProvider.GetProviderType())
	log.Debugf("[onStreamingResponseBody] isLastChunk=%v chunk: %s", isLastChunk, string(chunk))

	if handler, ok := activeProvider.(provider.StreamingResponseBodyHandler); ok {
		apiName, _ := ctx.GetContext(provider.CtxKeyApiName).(provider.ApiName)
		modifiedChunk, err := handler.OnStreamingResponseBody(ctx, apiName, chunk, isLastChunk)
		if err == nil && modifiedChunk != nil {
			return modifiedChunk
		}
		return chunk
	}
	if handler, ok := activeProvider.(provider.StreamingEventHandler); ok {
		apiName, _ := ctx.GetContext(provider.CtxKeyApiName).(provider.ApiName)
		events := provider.ExtractStreamingEvents(ctx, chunk)
		log.Debugf("[onStreamingResponseBody] %d events received", len(events))
		if len(events) == 0 {
			// No events are extracted, return the original chunk
			return chunk
		}
		var responseBuilder strings.Builder
		for _, event := range events {
			log.Debugf("processing event: %v", event)

			if event.IsEndData() {
				responseBuilder.WriteString(event.ToHttpString())
				continue
			}

			outputEvents, err := handler.OnStreamingEvent(ctx, apiName, event)
			if err != nil {
				log.Errorf("[onStreamingResponseBody] failed to process streaming event: %v\n%s", err, chunk)
				return chunk
			}
			if outputEvents == nil || len(outputEvents) == 0 {
				responseBuilder.WriteString(event.ToHttpString())
			} else {
				for _, outputEvent := range outputEvents {
					responseBuilder.WriteString(outputEvent.ToHttpString())
				}
			}
		}
		return []byte(responseBuilder.String())
	}
	return chunk
}

func onHttpResponseBody(ctx wrapper.HttpContext, pluginConfig config.PluginConfig, body []byte) types.Action {
	activeProvider := pluginConfig.GetProvider()

	if activeProvider == nil {
		log.Debugf("[onHttpResponseBody] no active provider, skip processing")
		return types.ActionContinue
	}

	log.Debugf("[onHttpResponseBody] provider=%s", activeProvider.GetProviderType())

	if handler, ok := activeProvider.(provider.TransformResponseBodyHandler); ok {
		apiName, _ := ctx.GetContext(provider.CtxKeyApiName).(provider.ApiName)
		body, err := handler.TransformResponseBody(ctx, apiName, body)
		if err != nil {
			_ = util.ErrorHandler("ai-proxy.proc_resp_body_failed", fmt.Errorf("failed to process response body: %v", err))
			return types.ActionContinue
		}
		if err = provider.ReplaceResponseBody(body); err != nil {
			_ = util.ErrorHandler("ai-proxy.replace_resp_body_failed", fmt.Errorf("failed to replace response body: %v", err))
		}
	}
	return types.ActionContinue
}

func normalizeOpenAiRequestBody(body []byte) []byte {
	var err error
	// Default setting include_usage.
	if gjson.GetBytes(body, "stream").Bool() {
		body, err = sjson.SetBytes(body, "stream_options.include_usage", true)
		if err != nil {
			log.Errorf("set include_usage failed, err:%s", err)
		}
	}
	return body
}

func checkStream(ctx wrapper.HttpContext) {
	contentType, err := proxywasm.GetHttpResponseHeader("Content-Type")
	if err != nil || !strings.HasPrefix(contentType, "text/event-stream") {
		if err != nil {
			log.Errorf("unable to load content-type header from response: %v", err)
		}
		ctx.BufferResponseBody()
		ctx.SetResponseBodyBufferLimit(defaultMaxBodyBytes)
	}
}

func getApiName(path string) provider.ApiName {
	// openai style
	if strings.HasSuffix(path, "/v1/chat/completions") {
		return provider.ApiNameChatCompletion
	}
	if strings.HasSuffix(path, "/v1/completions") {
		return provider.ApiNameCompletion
	}
	if strings.HasSuffix(path, "/v1/embeddings") {
		return provider.ApiNameEmbeddings
	}
	if strings.HasSuffix(path, "/v1/audio/speech") {
		return provider.ApiNameAudioSpeech
	}
	if strings.HasSuffix(path, "/v1/images/generations") {
		return provider.ApiNameImageGeneration
	}
	if strings.HasSuffix(path, "/v1/images/variations") {
		return provider.ApiNameImageVariation
	}
	if strings.HasSuffix(path, "/v1/images/edits") {
		return provider.ApiNameImageEdit
	}
	if strings.HasSuffix(path, "/v1/batches") {
		return provider.ApiNameBatches
	}
	if util.RegRetrieveBatchPath.MatchString(path) {
		return provider.ApiNameRetrieveBatch
	}
	if util.RegCancelBatchPath.MatchString(path) {
		return provider.ApiNameCancelBatch
	}
	if strings.HasSuffix(path, "/v1/files") {
		return provider.ApiNameFiles
	}
	if util.RegRetrieveFilePath.MatchString(path) {
		return provider.ApiNameRetrieveFile
	}
	if util.RegRetrieveFileContentPath.MatchString(path) {
		return provider.ApiNameRetrieveFileContent
	}
	if strings.HasSuffix(path, "/ai-gateway/api/v1/models") {
		return provider.ApiNameModels
	}
	// cohere style
	if strings.HasSuffix(path, "/v1/rerank") {
		return provider.ApiNameCohereV1Rerank
	}
	return ""
}
